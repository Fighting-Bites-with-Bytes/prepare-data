[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Preparing Tick Data",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "index.html#sec-abstract",
    "href": "index.html#sec-abstract",
    "title": "Preparing Tick Data",
    "section": "Abstract",
    "text": "Abstract\nThe tick prevention app “tick” is a mobile application that provides information on tick prevention and tick bite risk. The user is able to enter tick bites in a diary and is reminded to check for possible disease symptoms. Additionally, the user can enter the location of where the tick bite took place on a map, thus helping to identify tick hotspots. More information can be found here.\nIn this manner, over 50k tick bites were collected over a period of several years. This data can be used to identify tick hotspots and to predict tick bite risk based on environmental factors. We have a list of variables that experts think are important for predicting tick bite risk. We want to use machine learning to find out which variables are actually important and to predict tick bite risk for a given location. The goal is to create a model which outperforms the existing expert-based model."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Preparing Tick Data",
    "section": "Introduction",
    "text": "Introduction\nTicks are small arachnids that feed on the blood of mammals, birds and reptiles. Ticks are vectors for several diseases, including Lyme disease, tick-borne encephalitis, babesiosis and anaplasmosis. In Switzerland, tick bites are a common phenomenon. In 2019, 3.1% of the population was infected with Lyme disease. The tick prevention app “tick” was developed by the Institute for Natural Resource Sciences of the Zürcher Hochschule für Angewandte Wissenschaften (ZHAW) in 2015. The app is available for android and ios and provides information on tick prevention and tick bite risk. The user is able to enter tick bites in a diary and is reminded to check for possible disease symptoms. Additionally, the user can enter the location of where the tick bite took place on a map, thus helping to identify tick hotspots. More information can be found here.\nIn this manner, over 50k tick bites were collected over a period of several years. This data can be used to identify tick hotspots and to predict tick bite risk based on environmental factors. We have a list of variables that experts think are important for predicting tick bite risk. We want to use machine learning to find out which variables are actually important and to predict tick bite risk for a given location. The goal is to create model which outperforms the existing expert-based model.\nFor this, we have the following data available:\n\nDependent variable: Tick bite data (tick bites recorded by users of the tick app)\nPredictors: Geodata (raster data from various sources)"
  },
  {
    "objectID": "index.html#dependent-variable-tick-data",
    "href": "index.html#dependent-variable-tick-data",
    "title": "Preparing Tick Data",
    "section": "Dependent variable: Tick data",
    "text": "Dependent variable: Tick data\n\nTemporal dimension\nEvery year, the number of users using the app continues to grow and thus the number of recorded tick bites grows rapidly. Here are some figures showing the data from 2015 to 2019. More recent data can be acquired easily.\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n(b)\n\n\n\n\nFigure 1: The first tick bites were recorded in early 2015 and the latest beginning of 2020, more recent data is available. Most Tick bites are recorded May to July, with the peak being in June. Most tick bites are recorded between 20h and 22h. This is probably the instance when tick bites are noticed (e.g. in the shower).\n\n\n\n\nSpatial accuracy\nWhen specifying the location where the tick bite occurred, the user has the possibility to zoom into the map very closely (see Figure 2 (a)). The higher the zoom level the user chooses, the smaller the radius of the red circle. This radius can be used as a proxy of the accuracy of the user’s knowledge of where the tick bite occurred. The distribution of the accuracies is approximately log normal, see Figure 2 (b). Different versions of the app have different default values for accuracy. These default values are the peaks visible in Figure 2 (b).\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n(b)\n\n\n\n\nFigure 2: Accuracy of the tick bite locations can be inferred from the size of the radius the user provided when recording the tick bite.\n\n\n\n\nRisk, hazard and exposure\nThe risk of getting bitten by a tick can be formalized as follows:\n\\[\\text{Risk} = \\text{Hazard} \\times \\text{Exposure}\\]\nThis means that the risk is higher for areas not only where the Hazard is higher (i.e. more ticks), but also where Exposure is higher, i.e. more people. In other words, we must correct our data for population before making any predictions about the occurrence of ticks, as Figure 3 shows. If you are not familiar with swiss geography, the hotspots of tick bites are clearly around major cities like Zurich, Bern etc.\n\n\n\n\n\n\n\n(a) Raw data points\n\n\n\n\n\n\n\n(b) Point density (5km kernel filter)\n\n\n\n\nFigure 3: After filtering, the dataset consists of &gt; 30k tick bite recordings. Naturally, we have most recordings around big cities"
  },
  {
    "objectID": "index.html#predictors-geodata",
    "href": "index.html#predictors-geodata",
    "title": "Preparing Tick Data",
    "section": "Predictors: Geodata",
    "text": "Predictors: Geodata\nBased on expert knowledge, we have selected and prepared a number of possible datasets that can be used to predict tick occurrence.\n\nLand use statistics: A raster dataset with a 100m resolution with 72 basic categories\nPopulation: A raster dataset with 100m resolution with population count\nVegetation Height: A raster dataset with 50cm resolution describing the height of the vegetation in meters.\nDigital Elevation Model: A raster dataset with 50cm resolution describing elevation\n\nAs an extra challenge, participants could use historic temperature and precipitation data to create a dynamic, spatiotemporal forecast model. Historic weather data is available on various temporal scales (daily, weeekly, mothly…) at a high sptial resolution."
  },
  {
    "objectID": "01_Clean_reports.html",
    "href": "01_Clean_reports.html",
    "title": "1  Prepare Ticks data",
    "section": "",
    "text": "The tick data is user generated with the TickApp, see Section 1 .\n\nlibrary(\"dplyr\")\nlibrary(\"sf\")\nlibrary(\"readr\")\nlibrary(\"ggplot2\")\nlibrary(\"plotly\")\nlibrary(\"purrr\")\nlibrary(\"janitor\")\nlibrary(\"lubridate\")\n\noptions(\"sf_max.plot\" = 1)\n\n\ntick_reports &lt;- read_csv(\"data-raw/classified/tick-reports.csv\")\n\nRows: 68375 Columns: 17\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (3): date, uuid, comment\ndbl (14): ID, Lat., Lon., x, y, acc., date acc., body part, report type, age...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nswissboundaries_path &lt;- \"data-raw/public/swissTLM/swissBOUNDARIES3D_1_4_LV95_LN02.gdb\"\n# st_layers(swissboundaries_path)\n\nswitzerland &lt;- read_sf(swissboundaries_path, \"TLM_LANDESGEBIET\") |&gt;\n  st_zm() |&gt;\n  filter(NAME != \"Liechtenstein\") |&gt;\n  st_union() |&gt;\n  st_transform(2056)\n\n# clean column names and format columns\ntick_reports &lt;- tick_reports |&gt;\n  janitor::clean_names() |&gt;\n  mutate(across(c(id, x, y, acc, body_part, report_type, age, gender, host, pickup, deleted), ~ as.integer(.x))) |&gt;\n  mutate(across(c(lat, lon, date_acc), ~ as.numeric(.x))) |&gt;\n  mutate(\n    datetime = as.POSIXct(date, format = \"%Y-%m-%d %H:%M:%S\"),\n    date = as.Date(datetime)\n  )\n\n\n# remove rows without a data or data is older than 2015\ntick_reports &lt;- tick_reports |&gt;\n  filter(!is.na(date)) |&gt;\n  filter(date &gt; \"2015-01-01\")\n\n\n\n# remove reports outside a oversized bounding box\n# This is redundant, as the data will be filtered by swissBOUNDARIES3D later\nXMIN_21781 &lt;- 485000\nXMAX_21781 &lt;- 834000\nYMAX_21781 &lt;- 296000\nYMIN_21781 &lt;- 075000\n\ntick_reports &lt;- tick_reports %&gt;%\n  filter(x &lt; XMAX_21781, x &gt; XMIN_21781) %&gt;%\n  filter(y &lt; YMAX_21781, y &gt; YMIN_21781)\n\n# remove reports without a uuid or reports that are marked as deleted\ntick_reports &lt;- tick_reports %&gt;%\n  filter(uuid != \"\") %&gt;%\n  filter(deleted != 1)\n\n\n# till now, all steps are relatively straightforward. Now, opinions start to\n# matter.\n\n\n# remove reports with a spatial accuracy of more than 1 km radius\ntick_reports &lt;- tick_reports |&gt;\n  filter(acc &lt; 1000)\n\n# this step is not necessary anymore, I'll keep it here to document\n# default acc values. There are more default values it seems, as can be seen\n# when visualizing the data as a histogram\ntick_reports &lt;- tick_reports %&gt;%\n  filter(!(acc %in% c(57274L, 64434L, 1014L)))\n\ntick_reports_sf &lt;- st_as_sf(tick_reports, coords = c(\"lon\", \"lat\"), crs = 4326)\n\n# I dont know who came up with this, but it doesn't seem to be the case that there\n# are more locations near the default locations than outside\ndefault_locations &lt;- data.frame(lat = c(47.3647, 46.81), lon = c(8.5534, 8.23)) |&gt;\n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\n\nis_default &lt;- st_is_within_distance(tick_reports_sf, default_locations, 1000) |&gt;\n  map_lgl(\\(x)length(x) &gt; 0)\n\nsum(is_default)\n\n[1] 23\n\n# date accuracy only has two values: 43'200 and 432'000 (0.5 and 5 days?)\n# There are only 8k reports for the higher value, we can discard these\ntable(tick_reports$date_acc)\n\n\n 43200 432000 \n 39959   8253 \n\ntick_reports &lt;- tick_reports |&gt;\n  filter(date_acc &lt; 50000)\n\n\ntick_reports$date_acc &lt;- NULL\ntick_reports$body_part &lt;- NULL\ntick_reports$report_type &lt;- NULL\ntick_reports$age &lt;- NULL\ntick_reports$gender &lt;- NULL\ntick_reports$host &lt;- NULL\ntick_reports$pickup &lt;- NULL\ntick_reports$uuid &lt;- NULL\ntick_reports$comment &lt;- NULL\ntick_reports$deleted &lt;- NULL\n\n\n# some reports are obivously duplicates: same x and y and date (time may vary slighly)\ntick_reports |&gt;\n  group_by(x, y, date) |&gt;\n  filter(n() &gt; 1) |&gt;\n  select(id, datetime)\n\nAdding missing grouping variables: `x`, `y`, `date`\n\n\n# A tibble: 397 × 5\n# Groups:   x, y, date [176]\n        x      y date          id datetime           \n    &lt;int&gt;  &lt;int&gt; &lt;date&gt;     &lt;int&gt; &lt;dttm&gt;             \n 1 609729 261433 2015-04-13   118 2015-04-13 08:34:29\n 2 609729 261433 2015-04-13   119 2015-04-13 08:34:29\n 3 731962 253501 2015-08-26  2028 2015-08-26 20:46:02\n 4 731962 253501 2015-08-26  2029 2015-08-26 20:46:02\n 5 621424 264799 2016-07-18  5737 2016-07-18 13:52:11\n 6 621424 264799 2016-07-18  5738 2016-07-18 13:53:07\n 7 634791 249092 2016-07-25  5967 2016-07-25 08:18:49\n 8 634791 249092 2016-07-25  5968 2016-07-25 08:18:49\n 9 634791 249092 2016-07-25  5969 2016-07-25 08:18:49\n10 667235 212674 2016-08-04  6233 2016-08-04 09:34:30\n# ℹ 387 more rows\n\n# keep only distinct reports\ntick_reports &lt;- tick_reports |&gt;\n  distinct(x, y, date, .keep_all = TRUE)\n\n\ntick_reports$x &lt;- NULL\ntick_reports$y &lt;- NULL\n\ntick_reports_sf &lt;- st_as_sf(tick_reports, coords = c(\"lon\", \"lat\"), crs = 4326) |&gt;\n  st_transform(2056)\n\n\ntick_reports_sf &lt;- cbind(tick_reports_sf, st_coordinates(tick_reports_sf))\n\ntick_reports_sf &lt;- tick_reports_sf[switzerland, , ]\n\n\ntick_reports_sf$year &lt;- year(tick_reports_sf$date)\n\nggplot(tick_reports_sf) +\n  geom_sf() +\n  facet_wrap(~year)\n\n\n\n\n\ntick_reports_sf$year &lt;- NULL\n\nticks_path &lt;- \"data-processed/Ticks\"\n\nif(!dir.exists(ticks_path)) {dir.create(ticks_path)}\n\nst_write(tick_reports_sf, file.path(ticks_path, \"tick_reports.gpkg\"), \"reports_0.1\", overwrite = TRUE)\n\nLayer reports_0.1 in dataset data-processed/Ticks/tick_reports.gpkg already exists:\nuse either append=TRUE to append to layer or append=FALSE to overwrite layer\n\n\nError in eval(expr, envir, enclos): Dataset already exists."
  },
  {
    "objectID": "02_Prepare_covariates.html#mask",
    "href": "02_Prepare_covariates.html#mask",
    "title": "2  Prepare covariates",
    "section": "2.1 Mask",
    "text": "2.1 Mask\nCreating a raster to mask our results with (specifies resolution, extent and valid cell (no lakes))\n\n\n\nDataset\nswissBOUNDARIES3D\n\n\n\n\nDescription\nAdministrative boundaries\n\n\nSource\nBundesamt für Landestopographie, swisstopo1\n\n\n\n\n\n\nDataset\nswissTLMRegio\n\n\n\n\nDescription\nmedium res., vector based landscape model\n\n\nSource\nBundesamt für Landestopographie, swisstopo2\n\n\n\n\nswisstlm_temp_path &lt;- \"data-temp/swissTLM/\"\nunzip(\"data-raw/public/swissTLM/swisstlmregio_2022_2056.gdb.zip\", exdir = swisstlm_temp_path)\n\nswitzerland &lt;- read_sf(\"data-raw/public/swissTLM/swissBOUNDARIES3D_1_4_LV95_LN02.gdb\", \"TLM_LANDESGEBIET\") |&gt;\n  st_zm() |&gt;\n  filter(NAME != \"Liechtenstein\") |&gt;\n  st_union() |&gt;\n  st_transform(2056)\n\ntlm_region_lake &lt;- read_sf(file.path(swisstlm_temp_path, \"swissTLMRegio_Produkt_LV95.gdb\"), \"TLMRegio_Lake\")\n\ntlm_region_lake &lt;- tlm_region_lake[switzerland,,]\n\ntlm_region_lake &lt;- tlm_region_lake |&gt;\n    slice_max(SHAPE_Area, n = 10)\n\nmask_template &lt;- rast(crs = \"epsg:2056\", resolution = 100, xmin = 2485000, xmax = 2834000, ymin = 1075000, ymax = 1296000)\n\nswitzerland_mask &lt;- terra::rasterize(vect(switzerland), mask_template)\n\nswitzerland_mask &lt;- mask(switzerland_mask, tlm_region_lake,inverse = TRUE) \n\nmask_path &lt;- \"data-processed/Mask/\"\nif(!dir.exists(mask_path)) dir.create(mask_path, recursive = TRUE)\nwriteRaster(switzerland_mask, file.path(mask_path, \"Mask.tif\"), datatype = \"INT1U\", overwrite = TRUE)"
  },
  {
    "objectID": "02_Prepare_covariates.html#population",
    "href": "02_Prepare_covariates.html#population",
    "title": "2  Prepare covariates",
    "section": "2.2 Population",
    "text": "2.2 Population\n\n\n\nDataset\nPopulation\n\n\n\n\nDescription\nPopulation count and denisity\n\n\nSource\nBundesamt für Stastistik3\n\n\n\n\nzips &lt;- list.files(\"data-raw/public/Population/\", full.names = TRUE)\n\nzip_csvs &lt;- sapply(zips, \\(x){\n    df &lt;- unzip(x, list = TRUE)\n\n    df$Name[str_detect(df$Name, \"STATPOP\\\\d{4}.csv\")]\n})\n\n# names(zip_csvs)\n\npopulation_path &lt;- \"data-temp/Population\"\n\nif(!dir.exists(population_path)) dir.create(population_path)\n\n\nimap(zip_csvs, \\(csv_i, zip_i){\n    unzip(zip_i, csv_i, exdir = population_path, junkpaths = TRUE)\n}) |&gt;\n    invisible()\n\n\npop_csvs &lt;- list.files(population_path, \"STATPOP\", full.names = TRUE)\n\npop_csvs &lt;- pop_csvs[as.integer(str_match(basename(pop_csvs), \"\\\\d{4}\"))&gt;=2015]\n\npopulation &lt;- map(pop_csvs, \\(x){\n        read_delim(x, col_select = c(E_KOORD, N_KOORD, matches(\"B\\\\d{2}BTOT\"))) |&gt;\n            rast()\n    }) |&gt;\n    rast()\n\n# add crs information\ncrs(population) &lt;- \"epsg:2056\"\n\ndates &lt;- paste0(\"20\",str_match(names(population), \"B(\\\\d{2})BTOT\")[,2],\"-01-01\") |&gt;\n  as.Date()\n\ntime(population) &lt;- dates\n\nnames(population) &lt;- dates\n\npopulation_path2 &lt;- \"data-processed/Population\"\nif(!dir.exists(population_path)) dir.create(population_path2)\nwriteRaster(population, file.path(population_path2, \"Population_2015-2021.tif\"))\n\nError: [writeRaster] file exists. You can use 'overwrite=TRUE' to overwrite it"
  },
  {
    "objectID": "02_Prepare_covariates.html#elevation",
    "href": "02_Prepare_covariates.html#elevation",
    "title": "2  Prepare covariates",
    "section": "2.3 Elevation",
    "text": "2.3 Elevation\n\n\n\nDataset\nElevation\n\n\n\n\nDescription\nDigital Elevation Model (DEM) with 25m resolution\n\n\nSource\nBundesamt für Landestopographie, swisstopo4\n\n\n\n\n\ndata preperation\ndhm_path &lt;- \"data-temp/DHM/\"\nif(!dir.exists(dhm_path)) dir.create(dhm_path)\nunzip(\"data-raw/public/DHM/DHM25_MM_ASCII_GRID.zip\", exdir = dhm_path)\n\ndhm25 &lt;- rast(file.path(dhm_path, \"ASCII_GRID_1part/dhm25_grid_raster.asc\"))\n\n# set CRS information\ncrs(dhm25) &lt;- \"epsg: 21781\"\n\n\n\n# this takes a lot of time! I will provide the reprojected data as a download\ndhm25_2056 &lt;- project(dhm25, \"epsg: 2056\")\n\ndhm_path2 &lt;- \"data-processed/DHM\"\nif(!dir.exists(dhm_path2)) dir.create(dhm_path2)\nwriteRaster(dhm25_2056, file.path(dhm_path2, \"DHM25_2056.tif\"))"
  },
  {
    "objectID": "02_Prepare_covariates.html#weather",
    "href": "02_Prepare_covariates.html#weather",
    "title": "2  Prepare covariates",
    "section": "2.4 Weather",
    "text": "2.4 Weather\n\n\n\nDataset\nElevation\n\n\n\n\nDescription\nDifferent climate datasets (percipitation, sunshine, temperature…)\n\n\nSource\nMeteoswiss5 (not publicly available)\n\n\n\nVariables: - RhiresM: Monthly precipitation - SrelM: Monthly relative sunshine duration - TabsM: Monthly mean temperature\nA full list of the available variables can be found here.\n\nfiles_monthly &lt;- c(\"RhiresM_61_21_ch01r.swiss.lv95.zip\", \"SrelM_71_21_ch01r.swiss.lv95.zip\", \"TabsM_61_21_ch01r.swiss.lv95.zip\")\n\nweather_path &lt;- \"data-temp/Weather\"\nif(!dir.exists(weather_path)) dir.create(weather_path)\n\nunzip(\"data-raw/public/Wetter/Klimadaten_Feb22.zip\", files = file.path(\"Klimadaten_Feb22\", files_monthly), exdir = weather_path, junkpaths = TRUE)\n\nweather_zips &lt;- list.files(weather_path, pattern = \"\\\\.zip$\", full.names = TRUE)\n\n\nsapply(weather_zips, \\(x){\n    nc_names &lt;- unzip(x, list = TRUE)$Name\n    nc_select &lt;- nc_names[as.integer(str_match(nc_names, \"(\\\\d{4})\\\\d{8}\")[,2]) &gt;= 2015]\n    nc_select &lt;- nc_select[!is.na(nc_select)]\n    exdir &lt;- file.path(weather_path, str_match(basename(x), \"([a-zA-Z]+)\")[,2])\n    unzip(x, files = nc_select, exdir = exdir, junkpaths = TRUE)\n})\n\n\nfile.remove(weather_zips)\n \n\n\nweather_files &lt;- list.files(weather_path, \"\\\\.nc\", recursive = TRUE, full.names = TRUE)\n\n\nweather_path2 &lt;- \"data-processed/Weather\"\nmap(weather_files, \\(file_i){\n  rast_i &lt;- rast(file_i)\n\n  from_to &lt;- str_match(file_i, \"(\\\\d{8})\\\\d{4}_(\\\\d{8})\\\\d{4}\")[,2:3] |&gt;\n    as.Date(format = \"%Y%m%d\")\n\n  measurement &lt;- str_match(basename(file_i), \"^[a-zA-Z]+\")[,1]\n\n  new_filepath &lt;- file.path(weather_path2,measurement)\n  if(!dir.exists(new_filepath)) dir.create(new_filepath,recursive = TRUE)\n  new_filename &lt;- paste0(paste(from_to, collapse = \"_\"), \".tif\")\n\n\n\n  times &lt;- seq(from_to[1], from_to[2], by = \"month\")\n  time(rast_i) &lt;- times\n  crs(rast_i) &lt;- \"epsg:2056\"\n  writeRaster(rast_i, file.path(new_filepath, new_filename), overwrite = TRUE)\n})\n\nTo import the dataset:\n\nweather_files2 &lt;- list.files(weather_path2, \"\\\\.tif$\", recursive = TRUE, full.names = TRUE)\n\n\nrhires_2015 &lt;- rast(weather_files2[1])\n\nplot(rhires_2015)\n\n\n\n# to get the mean over all months\n\nmean(rhires_2015) |&gt;\n  plot()"
  },
  {
    "objectID": "02_Prepare_covariates.html#forest-mix",
    "href": "02_Prepare_covariates.html#forest-mix",
    "title": "2  Prepare covariates",
    "section": "2.5 Forest mix",
    "text": "2.5 Forest mix\n\n\n\nDataset\nForest Mix\n\n\n\n\nDescription\nPercentage of “Laubbaumholz” (deciduous trees) in a 10m raster\n\n\nSource\nBafu6\n\n\n\nThis dataset is also the basis of the dataset Forest Type which discriminates forest type into two classes based on the percentage of deciduous trees.\n\nforest_mix_path &lt;- \"data-raw/public/Forest/Waldmischungsgrad_2018_10m_2056.tif\"\nforest_mix &lt;- rast(forest_mix_path)\n\nplot(forest_mix)\n\n\n\nforest_mix_path2 &lt;- \"data-processed/Forest\"\nif(!dir.exists(forest_mix_path2)) dir.create(forest_mix_path2)\nfile.copy(forest_mix_path, file.path(forest_mix_path2, basename(forest_mix_path)), overwrite = TRUE)\n\n[1] TRUE\n\nbasename(forest_mix_path)\n\n[1] \"Waldmischungsgrad_2018_10m_2056.tif\""
  },
  {
    "objectID": "02_Prepare_covariates.html#footnotes",
    "href": "02_Prepare_covariates.html#footnotes",
    "title": "2  Prepare covariates",
    "section": "",
    "text": "https://www.swisstopo.admin.ch/en/geodata/landscape/boundaries3d.html↩︎\nhttps://www.swisstopo.admin.ch/en/geodata/landscape/tlmregio.htm↩︎\nhttps://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/gebaeude-wohnungen-haushalte-personen/bevoelkerung-haushalte-ab-2010.html: Scroll to the bottom and click on the “Geodata” Tab↩︎\nhttps://www.swisstopo.admin.ch/en/geodata/height/dhm25.html↩︎\nhttps://www.meteoschweiz.admin.ch/klima/klimawandel/entwicklung-temperatur-niederschlag-sonnenschein/monats-und-jahresgitterkarten.html↩︎\nhttps://map.geo.admin.ch/?lang=de&topic=ech&bgLayer=ch.swisstopo.pixelkarte-farbe&layers=ch.bafu.landesforstinventar-waldmischungsgrad&layers_opacity=0.5&E=2649824.25&N=1226629.34&zoom=10↩︎"
  }
]